import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sqlmanager import SqlManager
import numpy as np
from matplotlib.ticker import ScalarFormatter


class SummaryDataVisualizer:
    """
    Summary (Data is country specific)
    1. Ratio between (username and Unique Password) AND (email and unique password)between some countries. [Pre selected countries]
    2. Ratio between unique password vs domains [Pre Selected Countries]
    3. Top 10 Countries and their number of comrpomised - All data
     """
    def __init__(self, summary_data):
        """
        Initialize the SummaryDataVisualizer with summary data.
        :param summary_data: Aggregated summary data as a list of dictionaries.
        """
        # remove the unknown data point
        summary_data = self.remove_unknown(summary_data)
        self.summary_df = pd.DataFrame(summary_data)

    @staticmethod
    def remove_unknown(summary_data):
        index = 0
        for i in range(0, len(summary_data)):
            if summary_data[i]["country"] == "Unknown":
                break
            index += 1
        summary_data.pop(index)
        return summary_data

    def plot_username_password_pie_charts(self, countries):
        """
        Plots pie charts comparing unique usernames and unique passwords for selected countries.
        :param countries: List of countries to be included in the plot.
        """
        palette = sns.color_palette('Spectral')
        # Filter the data for selected countries
        filtered_df = self.summary_df[self.summary_df['country'].isin(
            countries)]

        # Determine the number of pie charts to plot
        num_countries = len(filtered_df)
        cols = 3  # You can adjust the number of columns based on your preference
        # rows = num_countries // cols + (num_countries % cols > 0)
        rows = (num_countries + cols - 1) // cols

        # Create a figure with multiple subplots
        fig, axes = plt.subplots(rows, cols, figsize=(cols * 6, rows * 6))
        axes = axes.flatten()  # Flatten in case of only one row

        for idx, (country, data) in enumerate(filtered_df.iterrows()):
            usernames = data['unique_usernames']
            passwords = data['unique_passwords']

            # In case usernames and passwords are zero, skip the plot
            if usernames == 0 and passwords == 0:
                continue

            color_pair = [palette[idx %
                                  len(palette)], palette[(idx + 1) % len(palette)]]

            axes[idx].pie([usernames, passwords], labels=['Unique Usernames', 'Unique Passwords'],
                          autopct='%1.1f%%', startangle=140, colors=color_pair)
            axes[idx].set_title(data["country"], fontweight="bold")

        # Adjust layout and show plot
        plt.suptitle(f'Unique Username to Unique Password Ratio Between {
                     len(countries)} Countries', fontsize=11)
        plt.subplots_adjust(top=0.99, bottom=.8)  # Adjust top spacing to create a gap
        # Adjust bottom spacing to accommodate any additional elements or padding
        fig.subplots_adjust(hspace=0.5, top=0.9, bottom=0.8)
        plt.tight_layout()
        plt.show()

    def plot_email_password_pie_charts(self, countries):
        """
        Plots pie charts comparing unique emails and unique passwords for selected countries.
        :param countries: List of countries to be included in the plot.
        """
        palette = sns.color_palette('Spectral')
        # Filter the data for selected countries
        filtered_df = self.summary_df[self.summary_df['country'].isin(
            countries)]

        # Determine the number of pie charts to plot
        num_countries = len(filtered_df)
        cols = 3  # You can adjust the number of columns based on your preference
        # rows = num_countries // cols + (num_countries % cols > 0)
        rows = (num_countries + cols - 1) // cols

        # Create a figure with multiple subplots
        fig, axes = plt.subplots(rows, cols, figsize=(cols * 6, rows * 6))
        axes = axes.flatten()  # Flatten in case of only one row

        for idx, (country, data) in enumerate(filtered_df.iterrows()):
            usernames = data['unique_emails']
            passwords = data['unique_passwords']

            # In case usernames and passwords are zero, skip the plot
            if usernames == 0 and passwords == 0:
                continue

            color_pair = [palette[idx %
                                  len(palette)], palette[(idx + 1) % len(palette)]]

            axes[idx].pie([usernames, passwords], labels=['Unique Emails', 'Unique Passwords'],
                          autopct='%1.1f%%', startangle=140, colors=color_pair)
            axes[idx].set_title(data["country"], fontweight="bold")

        # Adjust layout and show plot
        plt.suptitle(f'Unique Email to Unique Password Ratio Between {
                     len(countries)} Countries', fontsize=11)
        plt.subplots_adjust(top=0.99, bottom=.8)
        # Adjust bottom spacing to accommodate any additional elements or padding
        fig.subplots_adjust(hspace=0.5, top=0.9, bottom=0.8)
        plt.tight_layout()
        plt.show()

    def plot_password_domain_ratio(self, countries):
        """
        Plots the ratio of unique passwords to unique domains for selected countries.
        :param countries: List of countries to be included in the plot.
        """
        # Filter the data for selected countries
        filtered_df = self.summary_df[self.summary_df['country'].isin(
            countries)]

        # Calculate ratio
        filtered_df['Password_Domain_Ratio'] = filtered_df['unique_passwords'] / \
            filtered_df['unique_domains']

        # Plotting
        plt.figure(figsize=(12, 6))
        sns.barplot(x='country', y='Password_Domain_Ratio', data=filtered_df)
        plt.title('Ratio of Unique Passwords to Domains per Country')
        plt.show()

    def plot_top_countries_by_username_email(self):
        """
        Plots the top 10 countries by the number of compromised usernames and emails.
        """
        top_countries = self.summary_df.nlargest(
            10, ['unique_usernames', 'unique_emails', 'unique_passwords', 'unique_domains', 'unique_services'])

        # Melt the DataFrame to work with Seaborn's barplot
        melted_top_countries = top_countries.melt(id_vars='country', value_vars=[
                                                  'unique_usernames', 'unique_emails', 'unique_passwords',
                                                  'unique_domains', 'unique_services'],
                                                  var_name='Type', value_name='Count')

        # Plotting with Seaborn
        plt.figure(figsize=(12, 6))
        barplot = sns.barplot(data=melted_top_countries, x='country',
                              y='Count', hue='Type', palette='Spectral')

        plt.title('Top 10 Countries - Summary of all data')
        plt.xlabel('Country')
        plt.ylabel('Counts')
        plt.xticks(rotation=45)  # Rotate the x labels to make them readable
        barplot.yaxis.set_major_formatter(ScalarFormatter(useOffset=False))

        plt.subplots_adjust(bottom=0.2)  # Adjust bottom margin if needed
        plt.tight_layout()
        print(melted_top_countries.T)
        plt.show()


if __name__ == "__main__":

    # Example usage
    # Assuming aggregated_summary_data is the list of dictionaries containing the summary data
    sqlmanager = SqlManager()
    summary_data = sqlmanager.fetch_and_aggregate_summary_data()
    visualizer = SummaryDataVisualizer(summary_data)

    # Define the countries of interest
    countries_of_interest = ["United States", "Finland",
                             "Indonesia", "Viet Nam", "India", "Bangladesh"]  # Example countries
    # visualizer.plot_username_password_pie_charts(countries_of_interest) # done
    # visualizer.plot_email_password_pie_charts(countries_of_interest) # done
    visualizer.plot_top_countries_by_username_email() # looks okay!
